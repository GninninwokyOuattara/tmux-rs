# tmux-rs

An in-progress rust port of tmux. This project should be considered pre-alpha quality and may not necessarily be in a building state.

I don't think or want this project to displace tmux. I love using tmux.
Tmux will also continue development while I'm working on this port,
so the structure of the rust code must match that of the C project.

I started this endeavour as a way of getting first hand experience with using C2Rust.
It's simultaneously a great and a terrible tool. I was amazed when I used it that it
was able to produce rust code which compiled to a binary which was effectively equivalent to the original C binary.
Unfortunately, the resulting rust code ... leaves a lot to be desired.
My initial approach was starting with the mess generated by C2Rust and slowly de-duplicating
the section generated from the headers and then manually re-writing file by file.

The problem with this approach is the C2Rust duplicates the definitions from C `.h` header files.
This means every ~200 line C file results in a >1000 line rust file.
Furthermore, the Rust code generated is unsafe (this is okay), and unreadable (unacceptable).
The generated code doesn't retain the original intent of the C code, though it may be equivalent.
Think using constants like `42` instead of `b'*'` when the original C code used `'*'`.
The code may be equivalent, but it renders the resulting Rust code useless without the original C source.
That's not the goal of a port. You want to be able to through away the original code after the port and not have lost any information.

Eventually, I got to a point where I had so much in progress code in a non-building state that I gave up
and had to rethink this approach to porting. I've since started over many times.
My current approach is creating many "micro-crates" each of which correspond to each `.c` translational unit.
For now, this approach requires some manual editing of generated Makefiles. This isn't ideal.
If my understanding of autotools was better, I'd try to seamlessly integrate the building of the rust
crates into the original project structure. For now I have a `build.sh` script in the root which
calls make and cargo.

I think the better approach is to mimic the C functions abi with rust extern ffi definitions.
Then successively convert the ffi bindings into implementations. Using a single crate with modules
so it's easy to handle circular deps. I guess the problem is build system. It's difficult to have
a single file partially implemented. each can be all or nothing


One problem is translation has to occur at the file level. Requiring porting to happen in such
a way that there is a large amount of work in progress. Consider instead if it's possible to
break it up at the function level for larger files. It would depend on the file and function,
but I remove the function from the C file, but have it in the rust code so that there is no linking
issue.

# Steps

1. Pick a C file to port
  a. Pick a symbol (function or variable) to port
  b. cut the definition from the C file
  c. paste into the rust file and translate from C to Rust
2. Once all functions in a C file are ported
  a. Modify Makefile.am to remove the C file from sources list
  b. run `sh autogen.sh && ./configure` to regenerate Makefile


## Tips

- Use clang-format or other to reformat the C code quickly

- Picking a C file: Start with root files in the project. (files with no or few dependencies on the rest of the project)
- You cannot link multiple static rust libraries (.a) into a single compilation artifact. There will be duplicate symbols.
- Seems a common source of bugs is stubbing something and intending to come back to it later, but not. Avoid this.
- SEGFAULTS, crashes, panics are much easier to debug then infinite loops and other types of bugs because you get a stack trace

## Debugging Tips
- reduce problem to single function. set a breakpoint on that function. walk through it in old and new version and notice differences
- if crashing on user action, start, get pid of second process; attach gdb on second process without follow child mode; continue; trigger action, hopefully gdb will be at the point where the crash occurred

# Progress

need to be able to get some more useful information when.
more then just server exited unexpectedly.
- figure out abort / panic logs
- print a stacktrace on server process segfault

# NEXT
- I suspect that linking is shadowing some broken rust implementations, and maybe when compiling with rust the rust implementation is preferred
- improve imsg and imsg buffer implemnentation

# TODO
- review cmd_rotate_window.rs cmd_rotate_window_exec tailq_foreach calls
- memory sanitizer
- dump backtrace on abort
  - gdb break
    - client_main
    - client_connect
    - server_start
    - proc_fork_and_daemon
    - proc loop server loop
- better rust format string style logging functions
- tailq and rbtree
  - recheck all tailq, and rbtree structs for multiple links.
  - derive macro for rbtree and tailq
    - tailq support new generic type discriminant
  - fully complete library / crate implementation with documentation
- use bitflags instead of manually 
- use for_each_ in all instances
- implement fatal and fatalx which accept static rust string


remove these from the linking process
```
clang -fsanitize=address -fno-omit-frame-pointer -O0 -std=gnu99 -g -Wno-long-long -Wall -W -Wformat=2 -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -Wshadow -Wpointer-arith -Wsign-compare -Wundef -Wbad-function-cast -Winline -Wcast-align -Wdeclaration-after-statement -Wno-pointer-sign -Wno-attributes -Wno-unused-result -Wno-format-y2k      -o tmux cmd-parse.o     compat/fgetln.o compat/freezero.o compat/getdtablecount.o compat/getpeereid.o compat/getprogname.o compat/htonll.o compat/ntohll.o compat/setproctitle.o compat/strlcat.o compat/strlcpy.o compat/strtonum.o compat/recallocarray.o compat/getopt.o compat/imsg.o compat/imsg-buffer.o compat/vis.o compat/unvis.o compat/fdforkpty.o -L/home/collin/Git/tmux/tmux-3.5a/target/x86_64-unknown-linux-gnu/debug -ltmux_rs -lbsd -ltinfo  -levent_core  -lm  -lresolv
```

17 big files:
- [ ] 1535 grid // should probably be next, seeing crashes in grid-view

- [ ] 1120 layout
- [ ] 1243 format-draw
- [ ] 1266 mode-tree
- [ ] 1348 window-tree
- [ ] 1512 window-customize
- [ ] 1591 tty-keys
- [ ] 2035 status
- [ ] 2347 screen-write
- [ ] 3025 input
- [ ] 3186 tty
- [ ] 3392 server-client
- [ ] 5294 format
- [ ] 5786 window-copy
- [ ]  159 cmd-parse.y (partially translated), need to figure out an approach to get rid of yacc/bison

## After 100% Rust

- miri
- coverage
- convert to references instead of pointers
  - requirements to convert pointer to reference <https://doc.rust-lang.org/core/ptr/index.html#pointer-to-reference-conversion>
    - interleaving accesses between refs and ptrs seems to be not allowed
      - <https://doc.rust-lang.org/nightly/core/ptr/index.html#safety>
      - <https://github.com/rust-lang/unsafe-code-guidelines/issues/463>
    - when converting from ptr to ref need to ensure types are initialized and valid when passed into a function
    - read or writes through a ptr will invalidate a reference
    - also need to ensure no pointers are created and stored from the references
    - NonNull use as_uninit_mut
- get rid of paste crate, won't need to join symbols any more for C code
- figure out why building rust binary doesn't work
- implement cmd-parse.y parser in pest or nom to remove yacc as a build dependency


# Thoughts & Ideas
- emulate rust scoped enums with modules, structs and constants
- better rust-analyzer integration with C code

# Interesting Patterns

- goto labeled block translation
- bitflags

# C Stuff
- integer promotion rules
- rust literal value inference
- prototypes
- variadics

# Notes

## Compat

tmux is a *bsd project.
I'm not sure which bsd exactly, but it's clear from reading the source code there's many libc functions
used which don't exist on linux, and are provided by bsd. The tmux project makes use of code in the compat
directory and autotools to shim these functions on OS's which they aren't provided. The first area to port
is this. Many linux distro's provide some of these functions already implemented through a library called
libbsd. I made a libbsd-sys library that provides auto-generated rust bindings to this C library. The surface
area of these functions is quite small and could easily be reimplemented later to remove this dependency.

## queue.h and tree.h

The tmux project makes extensive use of macros in the `compat/queue.h` and `compat/tree.h` headers which
implement an intrusive linked list and intrusive red black tree. For the most part, I've been able
to mirror the implementations at the source level using Rust generics. This is a key area to get right.
The auto-generated expanded C macros generated a mess from this code. This code needs to be hand crafted
properly to make use of rust generics which is abi compatible with the original C code. Maybe in the future
it would make sense to instead make use of a crate which provides the same functionality such as [intrusive_collections](https://docs.rs/intrusive-collections/latest/intrusive_collections/).

## C pointer field access operator `->`

Once annoyance of porting C code which makes heavy use of pointers is having to convert uses of the `->` operator.
Rust has no such operator and pointers don't implement deref, so they must be translated to something like `(*w).field`.

For a bit, I thought I could implement by own smart pointer type which wrapped a `*mut T` or `NonNull` and also
implemented DerefMut. Unfortunately doing this requires that you can create a `&mut T` which would likely invoke
undefined behaviour in this context.

## BUGS

- exiting an opened window (not the original one ) causes server exit
- keybinding for vertical split prefix - doesn't seem to perform the correct action
  - related to current translation of arguments.c
- keybinding for new window prefix-c doesn't seem to work
  - started occurring after translating client.c
- TODO, noticed I flipped tranlation order of fields of args_parse struct. need to double check that all translations which use the initialization is correct
- Attaching to an existing tmux session is broken.
  - running `tmux attach` immediately crashes when a session exists
  - when running tmux while an existing tmux instance is running causes it to hang, killing the pane causes it to properly attach (likely do to my tmux config)
- Anything entered in command prompt enter causes crash
- with my rebinding C-b C to new window in current directory causes issues. with it unbound, there's no problem.
- crashes on my binding prefix g

- sendmsg in client to server causes SIGPIPE to be handled and exit control loop


Due to use after shadowing in client_.rs client_connect xasprintf usage
found by using LSAN_OPTIONS=report_objects=1
leak on exit:
```
❯ ./tmux
[exited]

=================================================================
==32510==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 28 byte(s) in 1 object(s) allocated from:
    #0 0x5596d8e5f64e in __interceptor_malloc (/home/collin/Git/tmux/tmux-3.5a/tmux+0x19964e) (BuildId: 960e62ee7f022a651d2c597decbeb02aba2b15cd)
    #1 0x7fbd5e1b0427 in __vasprintf_internal libio/./libio/vasprintf.c:71:30

SUMMARY: AddressSanitizer: 28 byte(s) leaked in 1 allocation(s).
```

```
// cs is null and causes segfault on tmux attach
    395  #[unsafe(no_mangle)]
    396  pub unsafe extern "C" fn control_write(c: *mut client, fmt: *const c_char, mut ap: ...) {
    397      let __func__ = c"control_write".as_ptr();
    398      unsafe {
    399          let cs = (*c).control_state;
    400
>   401          if tailq_empty(&raw mut (*cs).all_blocks) {
    402              control_vwrite(c, fmt, ap.as_va_list());
    403              return;
    404          }
```


```
   1684                  case EV_CLOSURE_EVENT: {                                        
   1685                          void (*evcb_callback)(evutil_socket_t, short, void *);
   1686                          short res;                                               
   1687                          EVUTIL_ASSERT(ev != NULL);                               
   1688                          evcb_callback = *ev->ev_callback;                        
   1689                          res = ev->ev_res;                                        
   1690                          EVBASE_RELEASE_LOCK(base, th_base_lock);                 
>  1691                          evcb_callback(ev->ev_fd, res, ev->ev_arg);  
```

## BUGS (found)

- Incorrect translation of do while
- Incorrect translation of != null check
- incorrect translation of self-referential struct (just used null to init because lazyness when translating)
- missing init for tailq in struct // the big one causing crash on init
- missing break at end of loop emulating goto in rb_remove: hangs on Ctrl-D
- missing field in struct translation
- incorrect field in struct. used struct instead of struct pointer
- flipped == args_type::ARGS_NONE instead of flipped != args_type::ARGS_NONE
- flipped != 0 instead of == 0 for coverting from !int_like_value in conditional
- incorrect translation of for loop with continue to while with continue and increment at end; increment isn't applied (cmd_find)
- incorrect translation of cmd_entry args_parse cb None, when should have been Some(cb): after translating cmd-display-menu immediately aborts on start
- typo in rb_right macro, expanded to access left field
- crashes when config file is completely commented out: missing early exit in cmdq_get_command, no return in function

- memcpy_(&raw mut tmp as *mut i8, in_, end); should have been: memcpy_(tmp, in_, end)
  -  because I switched to a pointer instead of buffer,but didn't change memcpy code
- typo fps, fsp, variable unused null , cmd-queue.c ( causing crash when C-b t for clock)
- missing C prototype :struct cmd_parse_commands * cmd_parse_do_buffer(const char *buf, size_t len, struct cmd_parse_input *pi, char **cause)
  - return address value truncated to int
- for loop never entered didn't init variable needed for side effect after for loop ended (arguments)
- incorrect for loop translation. used 1..count, but should have used while loop
- extra copy paste: duplicate value += 1; value +=1;
- flipped null check
- flipped : char		 acs[UCHAR_MAX + 1][2]; -> pub acs: [[c_char; c_uchar::MAX as usize + 1]; 2], should be [[c_char; 2]; c_uchar::MAX as usize + 1],
- crashes when typing 'c' because of one of my bindings (seems something fixed this)

## Why not [zellij](https://zellij.dev/)

I like tmux. I want tmux, not something else. Also I tried out using it before and the compilation time was 8 minutes on my machine.

# References

- [tmux](https://github.com/tmux/tmux)
- [C2Rust](https://github.com/immunant/c2rust)
- [rust-bindgen](https://rust-lang.github.io/rust-bindgen/)
- [Compiling C to Safe Rust, Formalized](https://arxiv.org/abs/2412.15042)
- [Porting C to Rust for a Fast and Safe AV1 Media Decoder](https://www.memorysafety.org/blog/porting-c-to-rust-for-av1/)
- [Fish 4.0: The Fish Of Theseus](https://fishshell.com/blog/rustport/)
- [Immunant's C2Rust tmux](https://github.com/immunant/tmux-rs)
- [Improved C Variadics in Rust and C2Rust](https://immunant.com/blog/2019/09/variadics/)
